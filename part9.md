# 제네릭스

## 9.1 제네릭 타입 파라미터
- 제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할 수 있음
- 코틀린의 제네릭은 자바랑 비슷. 하지만 자바와 달리 제네릭 타입의 타입 인자를 명시하거나 컴파일러가 추론할 수 있어야 한다.

### 9.1.1 제네릭 함수와 프로퍼티
- 모든 타입을 다룰 수 있는 함수를 구현하려면 제네릭 함수를 작성해야 한다.
- `fun <T> List<T>.slice(indices: IntRange) : List<T>`

- 확장 프로퍼티만 제네릭하게 만들 수 있다.

### 9.1.2 제네릭 클래스 선언
- 타입 파라미터를 이름 뒤에 붙이고 나면 클래스 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다. 

```
interface List<T> {
    operator fun get(index: Int): T
}
```

### 9.1.3 타입 파라미터 제약
- 타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
- 제약을 가하려면 타입 파라미터 이름 뒤에 콜론(:)을 표시하고 그 뒤에 상한 타입을 적으면 됨
- 드물지만 타입 파라미터에 대해 둘 이상의 제약을 가해야 하는 경우도 있음

### 9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정
- 널 가능성을 제외한 아무런 제약도 필요 없다면 Any? 대신 Any를 상한으로 사용하면 된다.
- `<T: Any>` 라는 제약은 T 타입이 항상 널이 될 수 없는 타입이 되게 보장함


## 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터


### 9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트



### 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언


### 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신


### 9.2.4 실체화한 타입 파라미터 제약



## 9.3 변성: 제네릭과 하위 타입

### 9.3.1 변성이 있는 이유: 인자를 함수에 넘기기

### 9.3.2 클래스, 타입, 하위 타입

### 9.3.3 공변성: 하위 타입 관계를 유지

### 9.3.4 반공변성: 뒤집힌 하위 타입 관계

### 9.3.5 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정

### 9.3.6 스타 프로젝션: 타입 인자 대신 * 사용





