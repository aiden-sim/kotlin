# 제네릭스

## 9.1 제네릭 타입 파라미터
- 제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할 수 있음
- 코틀린의 제네릭은 자바랑 비슷. 하지만 자바와 달리 제네릭 타입의 타입 인자를 명시하거나 컴파일러가 추론할 수 있어야 한다.

### 9.1.1 제네릭 함수와 프로퍼티
- 모든 타입을 다룰 수 있는 함수를 구현하려면 제네릭 함수를 작성해야 한다.
- `fun <T> List<T>.slice(indices: IntRange) : List<T>`

- 확장 프로퍼티만 제네릭하게 만들 수 있다.

### 9.1.2 제네릭 클래스 선언
- 타입 파라미터를 이름 뒤에 붙이고 나면 클래스 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다. 

```
interface List<T> {
    operator fun get(index: Int): T
}
```

### 9.1.3 타입 파라미터 제약
- 타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
- 제약을 가하려면 타입 파라미터 이름 뒤에 콜론(:)을 표시하고 그 뒤에 상한 타입을 적으면 됨
- 드물지만 타입 파라미터에 대해 둘 이상의 제약을 가해야 하는 경우도 있음

### 9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정
- 널 가능성을 제외한 아무런 제약도 필요 없다면 Any? 대신 Any를 상한으로 사용하면 된다.
- `<T: Any>` 라는 제약은 T 타입이 항상 널이 될 수 없는 타입이 되게 보장함

## 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터
- 자바는 하위 호환을 위해 타입 소거를 사용
- 코틀린에서는 함수를 inline 으로 선언하면 이 제약을 우회할 수 있음(실체화)

### 9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트
- 코틀린도 런타임 시전에 타입 인자 정보 지워짐
    - 컴파일러 시점에 타입에 대한 제약

- 제네릭 타입 소거의 나름 장점은 타입 정보의 크기가 줄어들어 메모리 사용량이 줄어듬
- 코틀린에서는 타입 인자를 명시하지 않고 제네릭을 사용할 수 없는데, 어떤 값이 집합이나 맵이 아니라는 사실을 어떻게 알까?!
    - 스타 프로젝션(*)을 사용하면 된다. 

- 코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 is 검사를 수행할 수 있다.
- 일반적으로 코틀린 컴파일러는 안전하지 못한 검사와 수행할 수 있는 검사를 알려 주기 위해 최대한 노력함

### 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언
- 자바 발할라 프로젝트
- 어떤 함수에 inline 키워드를 붙이면 컴파일러는 그 함수를 호출한 식을 모두 함수 본문으로 바꾼다.(복습)

- 인라인 함수에서만 실체화한 타입 인자를 사용할 수 있는 이유?
    - 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입 (실행 시점에 타입 소거의 영향을 받지 않음)
    - 컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다. 

### 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신

### 9.2.4 실체화한 타입 파라미터 제약
- 다음과 같은 경우 실체화한 타입 파라미터를 사용할 수 있다.
    - 타입 검사와 캐스팅(is, !is, as, as?)
    - 리플렉션 API(::class)
    - 코틀린 타입에 대응하는 java.lang.Class를 얻기(::class.java)
    - 다른 함수를 호출할 때 타입 인자로 사용

- 다음과 같은 일은 할 수 없음
    - 타입 파라미터 클래스의 인스턴스 생성
    - 타입 파라미터 클래스의 동반 객체 메소드 호출하기
    - 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
    - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기 

## 9.3 변성: 제네릭과 하위 타입
- 변성 개념은 List<String>와 List<Any>와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념
- 변성을 잘 활용하면 타입 안전성을 보장하는 API를 만들 수 있음

### 9.3.1 변성이 있는 이유: 인자를 함수에 넘기기
- 원소 추가나 변경이 없는 경우 List<String>을 List<Any> 대신 넘겨도 안전하다.
    
### 9.3.2 클래스, 타입, 하위 타입

    
### 9.3.3 공변성: 하위 타입 관계를 유지

    
### 9.3.4 반공변성: 뒤집힌 하위 타입 관계

    
### 9.3.5 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정

    
### 9.3.6 스타 프로젝션: 타입 인자 대신 * 사용














