# 제네릭스

## 9.1 제네릭 타입 파라미터
- 제네릭스를 사용하면 타입 파라미터를 받는 타입을 정의할 수 있음
- 코틀린의 제네릭은 자바랑 비슷. 하지만 자바와 달리 제네릭 타입의 타입 인자를 명시하거나 컴파일러가 추론할 수 있어야 한다.

### 9.1.1 제네릭 함수와 프로퍼티
- 모든 타입을 다룰 수 있는 함수를 구현하려면 제네릭 함수를 작성해야 한다.
- `fun <T> List<T>.slice(indices: IntRange) : List<T>`

- 확장 프로퍼티만 제네릭하게 만들 수 있다.

### 9.1.2 제네릭 클래스 선언
- 타입 파라미터를 이름 뒤에 붙이고 나면 클래스 본문 안에서 타입 파라미터를 다른 일반 타입처럼 사용할 수 있다. 

```
interface List<T> {
    operator fun get(index: Int): T
}
```

### 9.1.3 타입 파라미터 제약
- 타입 파라미터 제약은 클래스나 함수에 사용할 수 있는 타입 인자를 제한하는 기능
- 제약을 가하려면 타입 파라미터 이름 뒤에 콜론(:)을 표시하고 그 뒤에 상한 타입을 적으면 됨
- 드물지만 타입 파라미터에 대해 둘 이상의 제약을 가해야 하는 경우도 있음

### 9.1.4 타입 파라미터를 널이 될 수 없는 타입으로 한정
- 널 가능성을 제외한 아무런 제약도 필요 없다면 Any? 대신 Any를 상한으로 사용하면 된다.
- `<T: Any>` 라는 제약은 T 타입이 항상 널이 될 수 없는 타입이 되게 보장함

## 9.2 실행 시 제네릭스의 동작: 소거된 타입 파라미터와 실체화된 타입 파라미터
- 자바는 하위 호환을 위해 타입 소거를 사용
- 코틀린에서는 함수를 inline 으로 선언하면 이 제약을 우회할 수 있음(실체화)

### 9.2.1 실행 시점의 제네릭: 타입 검사와 캐스트
- 코틀린도 런타임 시전에 타입 인자 정보 지워짐
    - 컴파일러 시점에 타입에 대한 제약

- 제네릭 타입 소거의 나름 장점은 타입 정보의 크기가 줄어들어 메모리 사용량이 줄어듬
- 코틀린에서는 타입 인자를 명시하지 않고 제네릭을 사용할 수 없는데, 어떤 값이 집합이나 맵이 아니라는 사실을 어떻게 알까?!
    - 스타 프로젝션(*)을 사용하면 된다. 

- 코틀린 컴파일러는 컴파일 시점에 타입 정보가 주어진 경우에는 is 검사를 수행할 수 있다.
- 일반적으로 코틀린 컴파일러는 안전하지 못한 검사와 수행할 수 있는 검사를 알려 주기 위해 최대한 노력함

### 9.2.2 실체화한 타입 파라미터를 사용한 함수 선언
- 자바 발할라 프로젝트
- 어떤 함수에 inline 키워드를 붙이면 컴파일러는 그 함수를 호출한 식을 모두 함수 본문으로 바꾼다.(복습)

- 인라인 함수에서만 실체화한 타입 인자를 사용할 수 있는 이유?
    - 컴파일러는 인라인 함수의 본문을 구현한 바이트코드를 그 함수가 호출되는 모든 지점에 삽입 (실행 시점에 타입 소거의 영향을 받지 않음)
    - 컴파일러는 실체화한 타입 인자를 사용해 인라인 함수를 호출하는 각 부분의 정확한 타입 인자를 알 수 있다. 

### 9.2.3 실체화한 타입 파라미터로 클래스 참조 대신

### 9.2.4 실체화한 타입 파라미터 제약
- 다음과 같은 경우 실체화한 타입 파라미터를 사용할 수 있다.
    - 타입 검사와 캐스팅(is, !is, as, as?)
    - 리플렉션 API(::class)
    - 코틀린 타입에 대응하는 java.lang.Class를 얻기(::class.java)
    - 다른 함수를 호출할 때 타입 인자로 사용

- 다음과 같은 일은 할 수 없음
    - 타입 파라미터 클래스의 인스턴스 생성
    - 타입 파라미터 클래스의 동반 객체 메소드 호출하기
    - 실체화한 타입 파라미터를 요구하는 함수를 호출하면서 실체화하지 않은 타입 파라미터로 받은 타입을 타입 인자로 넘기기
    - 클래스, 프로퍼티, 인라인 함수가 아닌 함수의 타입 파라미터를 reified로 지정하기 

## 9.3 변성: 제네릭과 하위 타입
- 변성 개념은 List<String>와 List<Any>와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념
- 변성을 잘 활용하면 타입 안전성을 보장하는 API를 만들 수 있음

### 9.3.1 변성이 있는 이유: 인자를 함수에 넘기기
- 원소 추가나 변경이 없는 경우 List<String>을 List<Any> 대신 넘겨도 안전하다.
- 리스트의 원소를 추가하거나 변경한다면 타입 불일치가 생길 수 있어서 List<Any> 대신 List<String>을 넘길 수 없다.
    - 함수가 읽기 전용 리스트를 받는다면 더 구체적인 타입의 원소를 갖는 리스트를 그 함수에 넘길 수 있다. 하지만 리스트가 변경 가능하다면 그럴 수 없다.
    
### 9.3.2 클래스, 타입, 하위 타입
- 타입과 클래스의 차이점
    
- 일반 클래스(제네릭x) 에서는 클래스 이름을 바로 타입으로 사용 가능
    - nullable, null 가능하기 때문에 모든 코틀린 클래스는 적어도 둘 이상의 타입을 구성할 수 있음
    
- 제네릭 클래스는 올바른 타입을 얻으려면 제네릭 타입의 타입 파라미터를 구체적인 타입 인자로 바꿔줘야 한다.
    - 타입 사이의 관계를 논하기 위해 하위 타입이라는 개념을 잘 알아야 함
    
- 어떤 타입 A의 값이 필요한 모든 장소에 어떤 타입 B의 값을 넣어도 아무 문제없다면 타입 B는 타입 A의 하위 타입
    - ex) Int는 Number의 하위 타입
    
- 한 타입이 다른 타입의 하위 타입인지가 왜 중요 할까?
    - 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용
    
- 간단한 경우 하위 타입은 하위 클래스와 근본적으로 같음
- 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입
    
- 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가면 인스턴스타입 사이의 하위 타입 관계가 성립하지 않으면 그 제네릭 타입을 무공변 이라고 한다.
- 코틀린에서는 List 인터페이스는 읽기 전용 컬렉션이기 때문에 A가 B의 하위 타입이면 List<A>는 List<B>의 하위 타입이다. 이를 공변적 이라고 한다.    

    
### 9.3.3 공변성: 하위 타입 관계를 유지
- 코틀린에서는 제네릭 클래스가 타입 파라미터에 대해 공변적임을 표시하려면 타입 파라미터 이름 앞에 out을 넣어야 한다.

```
interface Producer<out T> {
    fun produce() : T   
}
```
    
- java에서는 <? extend T>

- 함수 파라미터 타입은 인(in) 위치, 함수 반환 타입은 아웃(out) 위치

- 타입 파라미터 T에 붙은 out 키워드는 다음 두 가지를 함께 의미
    - 공변성 : 하위 타입 관계가 유지된다.(Producer<Cat>은 Producer<Animal>의 하위 타입)
    - 사용 제한 : T를 아웃 위치에서만 사용 가능
    
- 변성은 코드에서 위험할 여지가 있는 메소드를 호출할 수 없게 만듦으로써 제네릭 타입의 인스턴스 역할을 하는 클래스 인스턴스를 잘못 사용하는 일이 없게 방지하는 역할
- 생성자 파라미터는 인이나 아웃 어느쪽도 아니다.
    
### 9.3.4 반공변성: 뒤집힌 하위 타입 관계
- 반공변 클래스의 하위 타입 관계는 공변 클래스의 경우와 반대다.
- 타입 B가 타입 A의 하위 타입인 경우 Consumer<A>가 Consumer<B> 의 하위 타입인 관계가 성립하면 제네릭 클래스 Consumer<T>는 타입 인자 T에 대해 반공변이다.
    
- ![image](https://github.com/simjunbo/kotlin/assets/7076334/12d587a4-4837-461d-85da-9663733d09de)
  
- java에서는 <? super T>
     
### 9.3.5 사용 지점 변성: 타입이 언급되는 지점에서 변성 지정
- 선언 지점 변성 : 클래스를 선언하면서 변성을 지정하면 그 클래스를 사용하는 모든 장소에 변성 지정자가 영향을 줘서 사용하기 편함
- 사용 지점 변성 : 자바에서는 타입 파라미터가 있는 타입을 사용할 때마다 해당 타입 파라미터를 하위 타입이나 상위 타입 중 어떤 타입으로 대치할 수 있는지 명시해야 됨
    
### 9.3.6 스타 프로젝션: 타입 인자 대신 * 사용
- 스타 프로젝션을 쓰는 쪽에 더 간결하지만 제네릭 타입 파라미터가 어떤 타입인지 굳이 알 필요가 없을 때만 스타 프로젝션을 사용할 수 있다.
- 스타 프로젝션을 사용할 때는 값을 만들어내는 메소드만 호출할 수 있고 그 값의 타입에는 신경을 쓰지 말아야 한다.
